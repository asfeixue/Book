# vmstat
vmstat 可以展示系统层面的服务器状态值。包括：CPU使用率，内存使用情况，虚拟内存交换情况，IO读写情况等。
vmstat工具使用时一般用到2个参数，1：采样的时间间隔数，单位是秒；2：采样的次数。
```
[root@xxxxx manage]# vmstat 2 3
procs -----------memory---------- ---swap-- -----io---- --system-- -----cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 1  0      0 1956136 238316 3169648    0    0     0    14    0    0  3  1 96  0  0  
 1  0      0 1955700 238316 3169688    0    0     0     6 1070 1233  3  1 96  0  0  
 0  0      0 1955492 238316 3169764    0    0     0   414 1067 1309  3  1 96  0  0
```
每个参数的含义如下：

**r** 表示运行队列(就是说多少个进程真的分配到CPU)，我测试的服务器目前CPU比较空闲，没什么程序在跑，当这个值超过了CPU数目，就会出现CPU瓶颈了。这个也和top的负载有关系，一般负载超过了3就比较高，超过了5就高，超过了10就不正常了，服务器的状态很危险。top的负载类似每秒的运行队列。如果运行队列过大，表示你的CPU很繁忙，一般会造成CPU使用率很高。

**b** 表示阻塞的进程,这个不多说，进程阻塞，大家懂的。

**swpd** 虚拟内存已使用的大小，如果大于0，表示你的机器物理内存不足了，如果不是程序内存泄露的原因，那么你该升级内存了或者把耗内存的任务迁移到其他机器。

**free**   空闲的物理内存的大小，我的机器内存总共8G，剩余1.9G。

**buff**   Linux/Unix系统是用来存储，目录里面有什么内容，权限等的缓存，我本机大概占用200多M

**cache** cache直接用来记忆我们打开的文件,给文件做缓冲。

**si**  每秒从磁盘读入虚拟内存的大小，如果这个值大于0，表示物理内存不够用或者内存泄露了，要查找耗内存进程解决掉。

**so**  每秒虚拟内存写入磁盘的大小，如果这个值大于0，同上。

**bi**  块设备每秒接收的块数量，这里的块设备是指系统上所有的磁盘和其他块设备，默认块大小是1024byte。

**bo** 块设备每秒发送的块数量，例如我们读取文件，bo就要大于0。bi和bo一般都要接近0，不然就是IO过于频繁，需要调整。

**in** 每秒CPU的中断次数，包括时间中断。

**cs** 每秒上下文切换次数，例如我们调用系统函数，就要进行上下文切换，线程的切换，也要进程上下文切换，这个值要越小越好，太大了，要考虑调低线程或者进程的数目,例如在apache和nginx这种web服务器中，我们一般做性能测试时会进行几千并发甚至几万并发的测试，选择web服务器的进程可以由进程或者线程的峰值一直下调，压测，直到cs到一个比较小的值，这个进程和线程数就是比较合适的值了。系统调用也是，每次调用系统函数，我们的代码就会进入内核空间，导致上下文切换，这个是很耗资源，也要尽量避免频繁调用系统函数。

cs过高会导致CPU像个搬运工，频繁在寄存器和运行队列之间奔波 ，更多的时间花在了线程切换，而不是真正工作的线程上。直接的消耗包括CPU寄存器需要保存和加载，系统调度器的代码需要执行。间接消耗在于多核cache之间的共享数据。

引起上下文切换的原因，对于抢占式操作系统而言， 大体有几种：
- 当前任务的时间片用完之后，系统CPU正常调度下一个任务；
- 当前任务碰到IO阻塞，调度线程将挂起此任务，继续下一个任务；
- 多个任务抢占锁资源，当前任务没有抢到，被调度器挂起，继续下一个任务；
- 用户代码挂起当前任务，让出CPU时间；
- 硬件中断；

```
pidstat -w   每个进程的context switching情况
pidstat -wt  细分到每个threads
cswch/s: 让步式上下文切换
切换上下文的次数，当某一任务处于阻塞等待时，将主动让出自己的CPU资源。

nvcswch/s: 抢占式上下文切换
切换上下文的次数，CPU分配给某一任务的时间片已经用完，因此将强迫该进程让出CPU的执行权。

因为pidstat报告的是每秒而不是每个测量周期的让步式上下文切换，因此让步式上下文切换浪费的时钟周期可以由pidstat -w的让步式上下文切换数除以虚拟处理器的数目而得出。

一般让步式上下文切换每个会浪费80000时钟周期，3.0GHz每秒的时钟周期是3,000,000,000。当让步式上下文切换损耗时钟周期占比3%~5%左右意味着存在锁竞争，此时就具备一定的优化价值。

计算表达式：
pidstat得出的cswch/s   /   虚拟内核数   *   80000   /   CPU每秒的时钟周期数 = 让步式上下文切换导致的CPU损耗(因锁竞争导致的CPU损耗)
```

**us** 用户CPU时间。

**sy** 系统CPU时间，如果太高，表示系统调用时间长，例如是IO操作频繁。

**id**  空闲 CPU时间，一般来说，id + us + sy = 100,一般来说id是空闲CPU使用率，us是用户CPU使用率，sy是系统CPU使用率。

**wt** 等待IO CPU时间。