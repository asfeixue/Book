# Lock

Lock实现相比synchronized方法和语句提供了更广泛锁操作。它们支持更灵活的结构，可能有完全不同的属性，并且可以支持多个相关联的Condition对象。

锁是多个线程之间用于控制共享资源访问权限的工具。通常来说，锁提供了对共享资源排它的访问权限：仅支持同一时间内一个线程可以获取锁并且共享资源的访问权限必须先获取锁。然而，一些锁允许并发访问共享资源，如：读锁ReadWriteLock。

synchronized方法或语句提供与之相关联对象的隐式监控锁，但是强制所有锁的获取与释放都发生在一个阻塞结构中：当多个锁被获取后，他们必须基于一定的顺序逐一释放，并且所有的锁必须在其获取时的上下文内释放。

虽然同步方法和语句的范围限定机制使得针对监视器的编程更简单，并且有助于规避大多数常规涉及锁的编程错误，但有些场合却需要更灵活的方式来使用锁。例如，遍历并发数据结构的一些算法需要使用"手动"或"链锁定"：你获取节点A的锁，然后获取B，然后释放A并且获取C，然后释放B获取D。锁接口的实现能够基于锁的获取与释放的不同顺序来实现上述技术。

随着灵活性的增加，使用的责任也随之增加。没有块结构的锁定会消除使用synchronized方法和语句带来的锁的自动释放。在大多数情况下，应当按照如下样式使用：
```
Lock l = ...;
 l.lock();
 try {
     // access the resource protected by this lock
 } finally {
     l.unlock();
 }
```

当锁定与解锁发生在不同的范围域内，必须注意确保锁定执行的所有代码都在try-finally 或 try-catch的保护的范围内，以便确保锁可以在必要的时候释放。

Lock实现提供了额外的功能，相对相对同步方法和语句，通过提供非阻塞方式获取锁(tryLock())，获取锁可中断(lockInterruptibly())，获取锁超时(tryLock(long, TimeUnit))。

Lock类可以提供和隐式监控锁完全不一样的行为与语义，例如保证有序，非重入使用，或死锁检测。如果一个实现提供这些特殊的语义，那么必须记录这些语义。

注意锁实例仅仅是一些普通的对象，在synchronized语句中被当做目标。获取监控器锁实例和调用实例的任何lock()方法没有特殊关系。为了避免混乱，建议不要这么使用Lock，除非在自定义实现中。

除非有明确的标识，否则任意参数传null值会抛出一个NullPointerException。

**内存同步**

所有的锁实现必须确保和内建的监控锁提供同样的内存同步语义。

- 成功的锁定操作和成功的Lock动作有同等内存同步效果。
- 成功的解锁操作和成功的Unlock动作有同样的内存同步效果。

不成功的锁定解锁操作，和可重入的锁定解锁操作，没有任何内存同步效果。

**实现注意事项**

3种获取锁的方式(可中断，不可中断，超时)在性能，有序或者其它实现方面存在差异。此外，中断正在获取锁的行为的能力在给定的Lock类上可能不可用。因此，Lock实现不需要对所有的三种形式的锁确保完全相同的保证或语义，也不需要支持对正在获取中的锁的行为的中断。实现必须清晰的记录每个锁定方法提供的语义和保证。还必须遵守此接口中定义的中断语义，锁中断支持范围：完全支持或者仅在方法入口支持。

中断通常意味着取消，针对中断的检查通常是不频繁的，一个实现可以使用正常的方法返回来响应一个中断。这样做是正确的，即便可以看出来中断发生在另一个动作已经不在阻塞线程后。实现需要记录这种实现行为。


