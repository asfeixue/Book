Mybatis源码解读.md

## 1.日志
logging package下的类图如下：
![日志类图](../static/logClassDiagram.png)

作为基础框架，本身的日志独立于任意日志框架，避免强绑定带来的依赖传递，同时又尽可能支持现有的任意日志框架，对具体使用的业务环境更友好。

mybatis按照如下顺序尝试加载具体日志框架：
    
    slf4j》commons-logging》log4j2》log4j》jdk-logging》no-log（丢弃所有日志）

从这里可以看出来，mybatis并未支持logback，如果日志用logback，最好还是通过slf4j来驱动。

## 2.缓存
每一个实现都完成一个原子语义，可以通过自由组合形成拥有多重语义的缓存实现，是一个灵活的缓存解决方案。
### BlockingCache
为每一个cache的数据项，映射一个ReentrantLock。然后在获取指定key的数据时，阻塞并等待对应的锁。阻塞可以设定一定的超时时间，也可以持续等待。

### FifoCache
基于双端队列的方式，提供先进先出的缓存操作模式。初始化大小为1024，可以自定义大小。选定的双端队列为LinkedList，本身不提供线程安全支持，需要业务方自行处理。当缓存容量达到预定容量时，删除头部元素。

### LoggingCache
在获取指定key的value的时候，累加请求次数，累加查询成功次数，然后输出命中率。

### LruCache
最近最少使用缓存。基于LinkedHashMap，当缓存容量超出初始容量后，将移除队列头部的后一个元素进而驱动缓存在新增元素时移除旧元素。添加新元素时，判断是否有需要移除的元素，此时如果并发，可能导致缓存中的部分数据无法被删除，导致内存泄露。所以，使用此次缓存需要业务方进行线程安全处理。

### ScheduledCache
简单调度缓存。每次操作时，触发清扫逻辑，超过预计时间，则全量清除。初始时间为1小时，可以自定义时间控制。

### SerializedCache
将实现Serializable的对象通过字节流转换为byte[]，然后进行cache。将值序列化成byte[]存储到缓存中，在跨线程操作时可以确保线程安全。

### SoftCache
基于SoftReference的一个缓存，初始强引用容量256，可以自定义。强引用用于当内存空间不足后，也可以保证一部分软引用对象不会被回收。

### WeakCache
基本定义和SoftCache类似。唯一的差别在于，SoftCache中的强引用操作的时候是有对象锁，会确保缓存value在强引用中存留一段时间。而WeakCache则相反，并不关心是否一定会存留，允许并发下丢弃强引用。
我认为，两者的差别，在于初始定义。只存在软引用的对象在内存不是很紧张时，不会被主动GC。而只存在弱引用的对象，只要扫描到就会被GC。那么在此场景下，内建强引用队列来保存部分弱引用对象的意义只具有一定的象征性。弱化并发控制逻辑则符合此定义。

### SynchronizedCache
在原子操作上，通过在方法上加锁控制并发。

### TransactionalCache
事务缓存，一次批量缓存数据或者回滚数据。clearOnCommit标记，可以用于防止幻读。

## 3.executor
